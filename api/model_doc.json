USER MODEL
-----------------------------

Description: Un driver c''est soit un eleve, soit un instructeur, selon le role attribué.  Il peut avoir plus d''un char (c''est un array).  

POST /api/users
{
  firstname : string,
  lastname : string,
  email : string,
  password: string,
  role : "driver"
  car : [
    {
      brand : string,
      model : string,
      year : number,
      color : string,
      drivetrain : <FWD, RWD, AWD>
    }
  ],
  experience : {
    type : < KART, CAR_ROAD_RACE, CAR_DRIFT, BIKE >,
    tracks : [
      {
        trackName : string
      }
    ],
    nbSession : integer [1..20+],
    nbYear : integer, [1..5+],
    note : string
  }
}



-------------------------------------------------------------------------
SESSION MODEL

Description : Une session au differente variation selon sont type.  Si c''est du lapping Solo, tu pourra entrer tes temps, si c''est du lapping avec coach, t''aura les champs lié a l''évaluation à remplir.  Donc le modèle d''une session se doit d''etre assez générique pour un coach qui fait unse ssion solo et pour un eval d''un eleve.

POST /api/users/:id/sessions/
{
  sessionDate : dateTime,
  track: string,
  group : < RED, YELLOW, GREEN, BLACK, INSTRUCTOR >,
  length : interger,
  sessionType : < LAPPING_SOLO, LAPPING_COACH, EVALUATION, COMPETITION >, 
  weather {
    track : < DRY,  WET >,
    temperature : decimal,
    sky : < CLEAR, VARIABLE, OVERCAST >
  }
  evaluation : {
    driverPosition : [1..5],   // Ici, j'utilisera des "stars"  dans le UI.  Comme dans iTune quand tu rate une tounes - de 1 à 5 étoiles.  Simple et rapide à remplir.
    flagKnowledge : [1..5],
    blendLineRespect : [1..5],
    carControl : [1..5],
    vision360 : [1..5],
    passing : [1..5],
    braking : [1..5],
    shifting : [1..5],
    trackLine : [1..5],
    pitOut : [1..5],
    promotionRecommended : < YES, NO >,
    promotedGroup : < NULL, YELLOW, GREEN, BLACK, INSTRUCTOR >,
    overallScore : [1..5],
    coachId : id,
    coachName : string,
    note : string 
  },
  timing : {
    bestTime : time,
    time : [time],
  },
  note : string
}